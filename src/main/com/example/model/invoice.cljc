(ns com.example.model.invoice
  (:require
    #?@(:clj [
              [cljc.java-time.local-date :as ld]
              [cljc.java-time.local-date-time :as ldt]
              [com.example.components.database-queries :as queries]
              [com.example.lib.pathom.wrappers :refer [defresolver]]])
    [com.fulcrologic.rad.type-support.date-time :as dt]
    [com.wsscode.pathom.connect :as pc]
    [taoensso.encore :as enc]
    [taoensso.timbre :as log]))

;; Fold account details into the invoice details, if desired
#?(:clj
   (defresolver customer-id [env {:invoice/keys [id]}]
     {::pc/input  #{:invoice/id}
      ::pc/output [:account/id]
      :check (constantly true)}
     {:account/id (queries/get-invoice-customer-id env id)}))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This is the workhorse of statistics reporting at the Pathom layer. The following
;; resolver does the database query for all of the items needed to complete any
;; resolvers that are dependent upon the groups.  The groups are generated by
;; this resolver in a parameterized manner so that filtering, sorting, and grouping by
;; user parameters are accomplished here. Then this resolver makes those groups
;; available on output to be consumed by the resolvers (above) that then generate
;; derived statistics from them.  This prevents the resolvers from having to redo
;; the grouping calculations at the expense of having to make sure they are
;; calculated here.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#?(:clj
   (defresolver invoice-statistics [{:keys [parser query-params] :as env} _]
     {::pc/output [{:invoice-statistics [{:invoice-statistics/groups [:key :values]}]}]
      ::pc/doc    "Pull and group the invoices and line items based on query-params. This then flows to other resolvers as input."
      :check      (constantly true)}
     ;; NOTE: you'd normally need to pass in tz as a param, or use it from session to localize the groupings.
     (let [{:keys    [start-date end-date]
            grouping :group-by} query-params
           ;; TODO: Actual start/end filter
           all-invoices     (get
                              (parser env [{:invoice/all-invoices [:invoice/id
                                                                   :invoice/date
                                                                   :invoice/total
                                                                   {:invoice/line-items [:line-item/quantity
                                                                                         :line-item/subtotal]}]}])
                              :invoice/all-invoices)
           ;; TODO: support date range on all-invoices
           invoices         (filterv (fn [{:invoice/keys [date]}]
                                       (and
                                         (or (nil? start-date) (<= (compare start-date date) 0))
                                         (or (nil? end-date) (<= (compare date end-date) 0))))
                              all-invoices)
           grouped-invoices (enc/map-keys (fn [ld] (if (keyword? ld)
                                                     ld
                                                     (dt/local-datetime->inst (ld/at-time ld 12 0))))
                              (group-by
                                (fn [{:invoice/keys [date]}]
                                  (case grouping
                                    :year (let [d (dt/inst->local-datetime date)]
                                            (-> (ldt/to-local-date d)
                                              (ld/with-day-of-month 1)
                                              (ld/with-month 1)))
                                    :month (let [d (dt/inst->local-datetime date)]
                                             (ld/with-day-of-month (ldt/to-local-date d) 1))
                                    :day (let [d (dt/inst->local-datetime date)]
                                           (ldt/to-local-date d))
                                    ;;default is summary
                                    :summary))
                                invoices))
           result           (reduce
                              (fn [result k]
                                (conj result {:key k :values (get grouped-invoices k)}))
                              []
                              (sort (keys grouped-invoices)))]
       {:invoice-statistics {:invoice-statistics/groups result}})))
